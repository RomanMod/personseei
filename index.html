<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>–í–∏–ø–∞–¥–∫–æ–≤–µ —Ñ–æ—Ç–æ –ª—é–¥–∏–Ω–∏ –∑ Wikidata</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f9f9f9;
            text-align: center;
            padding: 40px;
        }

        h1 {
            color: #333;
        }

        #person-image {
            display: block;
            max-width: 100%;
            max-height: 300px;
            width: auto;
            height: auto;
            border: 2px solid #999;
            border-radius: 10px;
            margin: 0 auto;
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }

        #person-image.loaded {
            opacity: 1;
        }

        #person-name {
            margin-top: 15px;
            font-size: 1.5em;
            font-weight: bold;
        }

        #progress {
            margin-top: 20px;
            font-style: italic;
            color: #888;
        }

        #progress.error {
            color: red;
        }

        .btn-container {
            margin-top: 20px;
        }

        .btn-container button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }

        .time-info {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }

        .stats {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            display: inline-block;
        }

        canvas {
            display: none;
        }
    </style>
</head>
<body>

    <h1>–í–∏–ø–∞–¥–∫–æ–≤–∞ –ª—é–¥–∏–Ω–∞ –∑ Wikidata</h1>
    <img id="person-image" src="" alt="–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ª—é–¥–∏–Ω–∏">
    <div id="person-name"></div>
    <div id="progress">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>

    <div class="btn-container">
        <button onclick="loadPerson(true)">
            üéØ –°—É–ø–µ—Ä –≤–∏–ø–∞–¥–∫–æ–≤–æ (–ø–æ–≤—ñ–ª—å–Ω–æ)
        </button>
        <div id="time-slow" class="time-info"></div>
        
        <button onclick="loadSession()">
            ‚ö° –°–µ—Å—ñ—è (–∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∞ –≤–∏–ø–∞–¥–∫–æ–≤—ñ—Å—Ç—å)
        </button>
        <div id="time-fast" class="time-info"></div>
    </div>

    <div class="stats">
        <div>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:</div>
        <div id="stats-slow">–ü–æ–≤—ñ–ª—å–Ω–∏–π —Ä–µ–∂–∏–º: -</div>
        <div id="stats-fast">–®–≤–∏–¥–∫–∏–π —Ä–µ–∂–∏–º: -</div>
    </div>

    <canvas id="image-canvas"></canvas>

    <script>
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        const settings = {
            superRandomPeople: false,
            RandomPeople: true,
            dynamicOffset: true,
            maxOffset: 200, // –£–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –ø—É–ª–∞
            maxPeople: 100, // –£–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –ø—É–ª–∞
            sessionPeople: 10,
            genderRatio: { male: 50, female: 50 },
            statusRatio: { alive: 50, deceased: 50 },
            excludeBlackAndWhite: true, // –§–∏–ª—å—Ç—Ä –ø–æ –≥–æ–¥—É
            colorAnalysis: false // –ê–Ω–∞–ª–∏–∑ —Ü–≤–µ—Ç–∞ –æ—Ç–∫–ª—é—á—ë–Ω –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        };

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        const stats = {
            slow: { count: 0, totalTime: 0, lastTime: 0 },
            fast: { count: 0, totalTime: 0, lastTime: 0 }
        };

        // –ö—ç—à –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
        const categoryCache = {};

        function updateStats(mode, time) {
            stats[mode].count++;
            stats[mode].totalTime += time;
            stats[mode].lastTime = time;
            const avgTime = stats[mode].totalTime / stats[mode].count;
            document.getElementById(`stats-${mode}`).textContent = 
                `${mode === 'slow' ? '–ü–æ–≤—ñ–ª—å–Ω–∏–π' : '–®–≤–∏–¥–∫–∏–π'} —Ä–µ–∂–∏–º: ` +
                `–û—Å—Ç–∞–Ω–Ω—î: ${time.toFixed(0)}–º—Å, ` +
                `–°–µ—Ä–µ–¥–Ω—î: ${avgTime.toFixed(0)}–º—Å, ` +
                `–ó–∞–ø–∏—Ç—ñ–≤: ${stats[mode].count}`;
            document.getElementById(`time-${mode}`).textContent = 
                `–ß–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è: ${time.toFixed(0)}–º—Å`;
        }

        async function getCommonsImageUrl(fileName) {
            const start = performance.now();
            try {
                const response = await fetch(`https://commons.wikimedia.org/w/api.php?action=query&titles=File:${encodeURIComponent(fileName)}&prop=imageinfo&iiprop=url&format=json&origin=*`);
                if (!response.ok) throw new Error(`Commons API error: ${response.status}`);
                const data = await response.json();
                const pages = data.query.pages;
                const page = pages[Object.keys(pages)[0]];
                console.log(`Commons API time: ${(performance.now() - start).toFixed(0)}ms`);
                if (!page.imageinfo) {
                    console.error(`No imageinfo for file: ${fileName}`);
                    return null;
                }
                return page.imageinfo[0].url;
            } catch (error) {
                console.error(`Failed to fetch Commons image for ${fileName}:`, error.message);
                return null;
            }
        }

        async function loadImageWithFallback(url, element) {
            return new Promise((resolve, reject) => {
                element.classList.remove('loaded');
                console.log(`Attempting to load image: ${url}`);
                element.onerror = () => {
                    console.warn(`Direct image load failed, trying proxy: ${url}`);
                    const proxyUrl = `https://images.weserv.nl/?url=${encodeURIComponent(url)}`;
                    element.onerror = () => {
                        console.error(`Proxy image load failed: ${proxyUrl}`);
                        element.src = 'https://via.placeholder.com/300';
                        element.classList.add('loaded');
                        reject(new Error('Both direct and proxy image load failed'));
                    };
                    element.src = proxyUrl;
                };
                element.onload = () => {
                    console.log(`Image loaded successfully: ${url}`);
                    element.classList.add('loaded');
                    resolve();
                };
                element.src = url;
            });
        }

        function isBlackAndWhiteImage(fileName) {
            if (!settings.excludeBlackAndWhite) return false;
            const yearMatch = fileName.match(/\b(19\d{2}|20\d{2})\b/);
            if (yearMatch) {
                const year = parseInt(yearMatch[0], 10);
                if (year < 1960) { // –°–º—è–≥—á–µ–Ω–æ —Å 1970 –¥–æ 1960
                    console.log(`Image excluded as black-and-white (year): ${fileName} (year: ${year})`);
                    return true;
                }
            }
            return false;
        }

        async function isGrayscaleImage(url) {
            if (!settings.colorAnalysis) return false;
            const start = performance.now();
            try {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 2000); // –¢–∞–π–º-–∞—É—Ç 2 —Å–µ–∫—É–Ω–¥—ã

                await new Promise((resolve, reject) => {
                    img.onload = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    img.onerror = () => {
                        clearTimeout(timeout);
                        reject(new Error('Failed to load image for color analysis'));
                    };
                    img.src = url;
                });

                const canvas = document.getElementById('image-canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, img.width, img.height).data;
                let grayscaleCount = 0;
                const totalPixels = img.width * img.height;
                const sampleRate = 20; // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π 20-–π –ø–∏–∫—Å–µ–ª—å
                const threshold = 20;

                for (let i = 0; i < imageData.length; i += 4 * sampleRate) {
                    const r = imageData[i];
                    const g = imageData[i + 1];
                    const b = imageData[i + 2];
                    if (Math.max(r, g, b) - Math.min(r, g, b) < threshold) {
                        grayscaleCount++;
                    }
                }

                const grayscaleRatio = grayscaleCount / (totalPixels / sampleRate);
                console.log(`Color analysis for ${url}: grayscale ratio = ${grayscaleRatio.toFixed(2)} (time: ${(performance.now() - start).toFixed(0)}ms)`);

                if (grayscaleRatio > 0.9) {
                    console.log(`Image excluded as grayscale: ${url}`);
                    return true;
                }
                return false;
            } catch (error) {
                console.error(`Color analysis failed for ${url}:`, error.message);
                return false; // –ù–µ –∏—Å–∫–ª—é—á–∞–µ–º –ø—Ä–∏ –æ—à–∏–±–∫–µ
            }
        }

        async function fetchPersonData(useRandom = true, category = null) {
            const cacheKey = category ? `${category.gender}_${category.status}` : 'random';
            if (categoryCache[cacheKey] && categoryCache[cacheKey].length) {
                const person = categoryCache[cacheKey].pop();
                console.log(`Using cached person for ${cacheKey}`);
                return person;
            }

            const start = performance.now();
            let query;
            let attempts = 0;
            const maxAttempts = 5; // –£–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç–∏

            const genderFilter = category?.gender === 'male' ? 'FILTER(?gender = wd:Q6581097)' :
                                category?.gender === 'female' ? 'FILTER(?gender = wd:Q6581072)' :
                                'FILTER(?gender IN (wd:Q6581097, wd:Q6581072))';
            const statusFilter = category?.status === 'alive' ? 'FILTER NOT EXISTS { ?person wdt:P570 ?deathDate }' :
                                category?.status === 'deceased' ? '?person wdt:P570 ?deathDate' :
                                'OPTIONAL { ?person wdt:P570 ?deathDate }';

            while (attempts < maxAttempts) {
                const offset = settings.dynamicOffset ? Math.floor(Math.random() * settings.maxOffset) : 0;
                if (useRandom && settings.superRandomPeople) {
                    query = `
                        SELECT ?person ?personLabel ?image ?country ?gender ?deathDate
                        WHERE {
                            ?person wdt:P31 wd:Q5;
                                    wdt:P18 ?image;
                                    wdt:P27 ?country;
                                    wdt:P21 ?gender.
                            ${genderFilter}.
                            ${statusFilter}.
                            ?person rdfs:label ?personLabel.
                            FILTER (LANG(?personLabel) = "en").
                        }
                        ORDER BY RAND()
                        LIMIT 1
                    `;
                } else {
                    query = `
                        SELECT ?person ?personLabel ?image ?country ?gender ?deathDate
                        WHERE {
                            ?person wdt:P31 wd:Q5;
                                    wdt:P18 ?image;
                                    wdt:P27 ?country;
                                    wdt:P21 ?gender.
                            ${genderFilter}.
                            ${statusFilter}.
                            ?person rdfs:label ?personLabel.
                            FILTER (LANG(?personLabel) = "en").
                        }
                        OFFSET ${offset}
                        LIMIT ${settings.maxPeople}
                    `;
                }

                const endpoint = 'https://query.wikidata.org/sparql';
                const url = `${endpoint}?query=${encodeURIComponent(query)}&format=json&nocache=${Date.now()}`;

                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 15000);

                try {
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/sparql-results+json',
                            'User-Agent': 'SimplePhotoApp/1.0 (https://romanmod.github.io/personseei/; krv.mod@gmail.com)',
                        },
                        signal: controller.signal
                    });

                    clearTimeout(timeout);
                    const data = await response.json();
                    let list = data.results.bindings;

                    console.log(`Wikidata query time: ${(performance.now() - start).toFixed(0)}ms (${useRandom ? 'random' : 'fast'})`);

                    if (!list.length) {
                        console.warn(`No results for category ${category?.gender}/${category?.status}, attempt ${attempts + 1}`);
                        attempts++;
                        continue;
                    }

                    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –≥–æ–¥—É
                    if (settings.excludeBlackAndWhite) {
                        list = list.filter(item => {
                            const fileName = decodeURIComponent(item.image.value.split('/').pop());
                            return !isBlackAndWhiteImage(fileName);
                        });
                    }

                    if (!list.length) {
                        console.warn(`No valid images after year filtering for category ${category?.gender}/${category?.status}, attempt ${attempts + 1}`);
                        attempts++;
                        continue;
                    }

                    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ü–≤–µ—Ç—É (—Ç–æ–ª—å–∫–æ –¥–ª—è –∂–∏–≤—ã—Ö, –µ—Å–ª–∏ –≤–∫–ª—é—á—ë–Ω)
                    if (settings.colorAnalysis && category?.status !== 'deceased') {
                        const filteredList = [];
                        for (const item of list.slice(0, 10)) { // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 10
                            const fileName = decodeURIComponent(item.image.value.split('/').pop());
                            const imageUrl = await getCommonsImageUrl(fileName);
                            if (imageUrl && !(await isGrayscaleImage(imageUrl))) {
                                filteredList.push(item);
                            }
                        }
                        list = filteredList;
                    }

                    if (!list.length) {
                        console.warn(`No valid images after color filtering for category ${category?.gender}/${category?.status}, attempt ${attempts + 1}`);
                        attempts++;
                        continue;
                    }

                    // –ö—ç—à–∏—Ä—É–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –∑–∞–ø–∏—Å–∏
                    if (!categoryCache[cacheKey]) categoryCache[cacheKey] = [];
                    categoryCache[cacheKey].push(...list.slice(1));
                    console.log(`Cached ${list.length - 1} persons for ${cacheKey}`);

                    if (useRandom) {
                        return list[0];
                    } else {
                        const randomIndex = Math.floor(Math.random() * list.length);
                        return list[randomIndex];
                    }
                } catch (error) {
                    console.error(`Wikidata query failed: ${error.message}`);
                    attempts++;
                    if (attempts === maxAttempts) {
                        throw new Error('No person found after multiple attempts');
                    }
                }
            }
            throw new Error('No person found after maximum attempts');
        }

        function updateUI({ personLabel, gender, deathDate }) {
            const progress = document.getElementById('progress');
            const personName = document.getElementById('person-name');
            progress.textContent = '–§–æ—Ç–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ!';
            progress.classList.remove('loading', 'error');
            const genderText = gender?.value.split('/').pop() === 'Q6581097' ? '–ß–æ–ª–æ–≤—ñ–∫' : '–ñ—ñ–Ω–∫–∞';
            const statusText = deathDate ? '–ú–µ—Ä—Ü' : '–ñ–∏–≤–∏–π';
            personName.textContent = `${personLabel.value} (${genderText}, ${statusText})`;
        }

        function handleError(errorMessage) {
            const progress = document.getElementById('progress');
            const personImage = document.getElementById('person-image');
            const personName = document.getElementById('person-name');

            progress.textContent = errorMessage;
            progress.classList.add('error');
            progress.classList.remove('loading');
            personImage.src = 'https://via.placeholder.com/300';
            personImage.classList.add('loaded'); // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –∑–∞–≥–ª—É—à–∫–∞ –≤–∏–¥–Ω–∞
            personName.textContent = '–¢–µ—Å—Ç–æ–≤–∏–π –ø–µ—Ä—Å–æ–Ω–∞–∂';
        }

        async function loadPerson(useRandom = true, category = null) {
            const startTime = performance.now();
            const mode = useRandom ? 'slow' : 'fast';
            const progress = document.getElementById('progress');
            const personImage = document.getElementById('person-image');
            const personName = document.getElementById('person-name');

            progress.textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö...';
            progress.classList.add('loading');
            progress.classList.remove('error');
            personImage.src = '';
            personName.textContent = '';
            personImage.classList.remove('loaded');

            try {
                const person = await fetchPersonData(useRandom, category);
                if (!person) throw new Error('No person found');

                progress.textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è...';
                const fileName = decodeURIComponent(person.image.value.split('/').pop());
                if (isBlackAndWhiteImage(fileName)) {
                    throw new Error(`Image excluded as black-and-white: ${fileName}`);
                }

                const imageUrl = await getCommonsImageUrl(fileName);
                if (!imageUrl) throw new Error(`Invalid image: ${fileName}`);

                if (settings.colorAnalysis && category?.status !== 'deceased' && await isGrayscaleImage(imageUrl)) {
                    throw new Error(`Image excluded as grayscale: ${fileName}`);
                }

                await loadImageWithFallback(imageUrl, personImage);
                updateUI(person);
                
                const totalTime = performance.now() - startTime;
                updateStats(mode, totalTime);
            } catch (error) {
                console.error('–ü–æ–º–∏–ª–∫–∞:', error.message);
                let message = '–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è';

                if (error.message.includes('Timeout')) {
                    message = '–¢–∞–π–º-–∞—É—Ç –∑–∞–ø–∏—Ç—É –¥–æ Wikidata';
                } else if (error.message.includes('HTTP 400')) {
                    message = '–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏–π SPARQL-–∑–∞–ø–∏—Ç';
                } else if (error.message.includes('No person found')) {
                    message = '–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –¥–∞–Ω–∏—Ö –ø—Ä–æ –ª—é–¥–∏–Ω—É';
                } else if (error.message.includes('Invalid image')) {
                    message = `–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è: ${error.message}`;
                } else if (error.message.includes('black-and-white') || error.message.includes('grayscale')) {
                    message = `–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ø—Ä–æ–ø—É—â–µ–Ω–æ —è–∫ —á—ë—Ä–Ω–æ-–±–µ–ª–æ–µ: ${error.message}`;
                }

                handleError(message);
                const totalTime = performance.now() - startTime;
                document.getElementById(`time-${mode}`).textContent = 
                    `–ü–æ–º–∏–ª–∫–∞ –ø—ñ—Å–ª—è ${totalTime.toFixed(0)}–º—Å`;
            }
        }

        async function loadPersonFromData(person) {
            const startTime = performance.now();
            const mode = 'fast';
            const progress = document.getElementById('progress');
            const personImage = document.getElementById('person-image');
            const personName = document.getElementById('person-name');

            progress.textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è...';
            progress.classList.add('loading');
            progress.classList.remove('error');
            personImage.src = '';
            personName.textContent = '';
            personImage.classList.remove('loaded');

            try {
                const fileName = decodeURIComponent(person.image.value.split('/').pop());
                if (isBlackAndWhiteImage(fileName)) {
                    throw new Error(`Image excluded as black-and-white: ${fileName}`);
                }

                const imageUrl = await getCommonsImageUrl(fileName);
                if (!imageUrl) throw new Error(`Invalid image: ${fileName}`);

                if (settings.colorAnalysis && person.deathDate?.value && await isGrayscaleImage(imageUrl)) {
                    throw new Error(`Image excluded as grayscale: ${fileName}`);
                }

                await loadImageWithFallback(imageUrl, personImage);
                updateUI(person);
                
                const totalTime = performance.now() - startTime;
                updateStats(mode, totalTime);
            } catch (error) {
                console.error('–ü–æ–º–∏–ª–∫–∞:', error.message);
                let message = error.message.includes('Invalid image') 
                    ? `–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è: ${error.message}`
                    : error.message.includes('black-and-white') || error.message.includes('grayscale') 
                    ? `–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ø—Ä–æ–ø—É—â–µ–Ω–æ —è–∫ —á—ë—Ä–Ω–æ-–±–µ–ª–æ–µ: ${error.message}`
                    : '–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è';
                handleError(message);
                const totalTime = performance.now() - startTime;
                document.getElementById(`time-${mode}`).textContent = 
                    `–ü–æ–º–∏–ª–∫–∞ –ø—ñ—Å–ª—è ${totalTime.toFixed(0)}–º—Å`;
            }
        }

        async function loadSession() {
            let sessionCount = 0;
            const categories = [
                { gender: 'male', status: 'alive' },
                { gender: 'male', status: 'deceased' },
                { gender: 'female', status: 'alive' },
                { gender: 'female', status: 'deceased' }
            ];
            const sessionList = [];

            document.getElementById('progress').textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –¥–ª—è —Å–µ—Å—ñ—ó...';
            try {
                const promises = categories.map(async (category, i) => {
                    const count = i % 2 === 0 ? 3 : 2; // 3, 2, 3, 2 –¥–ª—è 50/50
                    const results = [];
                    for (let j = 0; j < count; j++) {
                        try {
                            const person = await fetchPersonData(false, category);
                            results.push(person);
                        } catch (error) {
                            console.error(`Error in category ${category.gender}/${category.status}:`, error);
                            // –ü–æ–ø—Ä–æ–±—É–µ–º –¥—Ä—É–≥—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é
                            const fallbackCategory = categories[(i + 1) % categories.length];
                            try {
                                const person = await fetchPersonData(false, fallbackCategory);
                                results.push(person);
                            } catch (fallbackError) {
                                console.error(`Fallback failed for ${fallbackCategory.gender}/${fallbackCategory.status}:`, fallbackError);
                                results.push(null);
                            }
                        }
                    }
                    return results;
                });
                const results = await Promise.all(promises);
                results.flat().forEach(person => sessionList.push(person));
            } catch (error) {
                console.error('Session data loading failed:', error);
                handleError('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –¥–∞–Ω—ñ –¥–ª—è —Å–µ—Å—ñ—ó');
                return;
            }

            for (const person of sessionList) {
                document.getElementById('progress').textContent = `–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ª—é–¥–∏–Ω–∏ ${sessionCount + 1} –∑ ${settings.sessionPeople}...`;
                if (person) {
                    await loadPersonFromData(person);
                } else {
                    handleError('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ª—é–¥–∏–Ω—É –¥–ª—è —Ü—ñ—î—ó –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó');
                }
                sessionCount++;
                if (sessionCount < settings.sessionPeople) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            document.getElementById('progress').textContent = `–°–µ—Å—ñ—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ (${settings.sessionPeople} –æ—Å—ñ–±)`;
        }

        window.onload = () => {
            loadSession();
        };
    </script>

</body>
</html>
