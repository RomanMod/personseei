<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>–í–∏–ø–∞–¥–∫–æ–≤–µ —Ñ–æ—Ç–æ –ª—é–¥–∏–Ω–∏ –∑ Wikidata</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f9f9f9;
            text-align: center;
            padding: 40px;
        }

        h1 {
            color: #333;
        }

        #person-image {
            display: block;
            max-width: 100%;
            max-height: 300px;
            width: auto;
            height: auto;
            border: 2px solid #999;
            border-radius: 10px;
            margin: 0 auto;
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }

        #person-image.loaded {
            opacity: 1;
        }

        #person-name {
            margin-top: 15px;
            font-size: 1.5em;
            font-weight: bold;
        }

        #progress {
            margin-top: 20px;
            font-style: italic;
            color: #888;
        }

        #progress.error {
            color: red;
        }

        .btn-container {
            margin-top: 20px;
        }

        .btn-container button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }

        .time-info {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }

        .stats {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            display: inline-block;
        }
    </style>
</head>
<body>

    <h1>–í–∏–ø–∞–¥–∫–æ–≤–∞ –ª—é–¥–∏–Ω–∞ –∑ Wikidata</h1>
    <img id="person-image" src="" alt="–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ª—é–¥–∏–Ω–∏">
    <div id="person-name"></div>
    <div id="progress">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>

    <div class="btn-container">
        <button onclick="loadPerson(true)">
            üéØ –°—É–ø–µ—Ä –≤–∏–ø–∞–¥–∫–æ–≤–æ (–ø–æ–≤—ñ–ª—å–Ω–æ)
        </button>
        <div id="time-slow" class="time-info"></div>
        
        <button onclick="loadSession()">
            ‚ö° –°–µ—Å—ñ—è (–∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∞ –≤–∏–ø–∞–¥–∫–æ–≤—ñ—Å—Ç—å)
        </button>
        <div id="time-fast" class="time-info"></div>
    </div>

    <div class="stats">
        <div>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:</div>
        <div id="stats-slow">–ü–æ–≤—ñ–ª—å–Ω–∏–π —Ä–µ–∂–∏–º: -</div>
        <div id="stats-fast">–®–≤–∏–¥–∫–∏–π —Ä–µ–∂–∏–º: -</div>
    </div>

    <script>
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        const settings = {
            superRandomPeople: false,
            RandomPeople: true,
            dynamicOffset: true,
            maxOffset: 1000,
            maxPeople: 50,
            sessionPeople: 10,
            genderRatio: { male: 50, female: 50 },
            statusRatio: { alive: 50, deceased: 50 },
            excludeBlackAndWhite: true // –ò—Å–∫–ª—é—á–∞—Ç—å —á—ë—Ä–Ω–æ-–±–µ–ª—ã–µ —Ñ–æ—Ç–æ –¥–ª—è –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
        };

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        const stats = {
            slow: { count: 0, totalTime: 0, lastTime: 0 },
            fast: { count: 0, totalTime: 0, lastTime: 0 }
        };

        // –ö—ç—à –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∞–Ω–∞–ª–∏–∑–∞ RGB
        const rgbCache = JSON.parse(localStorage.getItem('rgbCache')) || {};

        function updateStats(mode, time) {
            stats[mode].count++;
            stats[mode].totalTime += time;
            stats[mode].lastTime = time;
            const avgTime = stats[mode].totalTime / stats[mode].count;
            document.getElementById(`stats-${mode}`).textContent = 
                `${mode === 'slow' ? '–ü–æ–≤—ñ–ª—å–Ω–∏–π' : '–®–≤–∏–¥–∫–∏–π'} —Ä–µ–∂–∏–º: ` +
                `–û—Å—Ç–∞–Ω–Ω—î: ${time.toFixed(0)}–º—Å, ` +
                `–°–µ—Ä–µ–¥–Ω—î: ${avgTime.toFixed(0)}–º—Å, ` +
                `–ó–∞–ø–∏—Ç—ñ–≤: ${stats[mode].count}`;
            document.getElementById(`time-${mode}`).textContent = 
                `–ß–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è: ${time.toFixed(0)}–º—Å`;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —á—ë—Ä–Ω–æ-–±–µ–ª—ã–º
        async function isBlackAndWhite(imageUrl) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
            if (rgbCache[imageUrl] !== undefined) {
                console.log(`Using cached RGB result for ${imageUrl}: ${rgbCache[imageUrl] ? 'black-and-white' : 'color'}`);
                return rgbCache[imageUrl];
            }

            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 100;
                    canvas.height = 100;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, 100, 100);

                    const imageData = ctx.getImageData(0, 0, 100, 100).data;
                    let rSum = 0, gSum = 0, bSum = 0;
                    let rSquareSum = 0, gSquareSum = 0, bSquareSum = 0;
                    let count = 0;

                    for (let i = 0; i < imageData.length; i += 4) {
                        const r = imageData[i];
                        const g = imageData[i + 1];
                        const b = imageData[i + 2];
                        rSum += r;
                        gSum += g;
                        bSum += b;
                        rSquareSum += r * r;
                        gSquareSum += g * g;
                        bSquareSum += b * b;
                        count++;
                    }

                    const rMean = rSum / count;
                    const gMean = gSum / count;
                    const bMean = bSum / count;
                    const rStdDev = Math.sqrt((rSquareSum / count) - (rMean * rMean));
                    const gStdDev = Math.sqrt((gSquareSum / count) - (gMean * gMean));
                    const bStdDev = Math.sqrt((bSquareSum / count) - (bMean * bMean));

                    const isBW = rStdDev < 20 && gStdDev < 20 && bStdDev < 20;
                    console.log(`Image ${imageUrl} is ${isBW ? 'black-and-white' : 'color'} (R:${rStdDev.toFixed(2)}, G:${gStdDev.toFixed(2)}, B:${bStdDev.toFixed(2)})`);
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
                    rgbCache[imageUrl] = isBW;
                    localStorage.setItem('rgbCache', JSON.stringify(rgbCache));
                    
                    resolve(isBW);
                };
                img.onerror = () => {
                    console.error(`Failed to load image for RGB analysis: ${imageUrl}`);
                    resolve(false);
                };
                img.src = imageUrl;
            });
        }

        async function getCommonsImageUrl(fileName) {
            const start = performance.now();
            try {
                const response = await fetch(`https://commons.wikimedia.org/w/api.php?action=query&titles=File:${encodeURIComponent(fileName)}&prop=imageinfo&iiprop=url&format=json&origin=*`);
                if (!response.ok) throw new Error(`Commons API error: ${response.status}`);
                const data = await response.json();
                const pages = data.query.pages;
                const page = pages[Object.keys(pages)[0]];
                console.log(`Commons API time: ${(performance.now() - start).toFixed(0)}ms`);
                if (!page.imageinfo) {
                    console.error(`No imageinfo for file: ${fileName}`);
                    return null;
                }
                return page.imageinfo[0].url;
            } catch (error) {
                console.error(`Failed to fetch Commons image for ${fileName}:`, error.message);
                return null;
            }
        }

        async function loadImageWithFallback(url, element) {
            return new Promise((resolve, reject) => {
                element.classList.remove('loaded');
                console.log(`Attempting to load image: ${url}`);
                element.onerror = () => {
                    console.warn(`Direct image load failed, trying proxy: ${url}`);
                    const proxyUrl = `https://images.weserv.nl/?url=${encodeURIComponent(url)}`;
                    element.onerror = () => {
                        console.error(`Proxy image load failed: ${proxyUrl}`);
                        element.src = 'https://via.placeholder.com/300';
                        element.classList.add('loaded');
                        reject(new Error('Both direct and proxy image load failed'));
                    };
                    element.src = proxyUrl;
                };
                element.onload = () => {
                    console.log(`Image loaded successfully: ${url}`);
                    element.classList.add('loaded');
                    resolve();
                };
                element.src = url;
            });
        }

        async function fetchPersonData(useRandom = true, category = null) {
            const start = performance.now();
            let query;
            let attempts = 0;
            const maxAttempts = 3;

            const genderFilter = category?.gender === 'male' ? 'FILTER(?gender = wd:Q6581097)' :
                                category?.gender === 'female' ? 'FILTER(?gender = wd:Q6581072)' :
                                'FILTER(?gender IN (wd:Q6581097, wd:Q6581072))';
            const statusFilter = category?.status === 'alive' ? 'FILTER NOT EXISTS { ?person wdt:P570 ?deathDate }' :
                                category?.status === 'deceased' ? '?person wdt:P570 ?deathDate' :
                                'OPTIONAL { ?person wdt:P570 ?deathDate }';

            while (attempts < maxAttempts) {
                const offset = settings.dynamicOffset ? Math.floor(Math.random() * settings.maxOffset) : 0;
                if (useRandom && settings.superRandomPeople) {
                    query = `
                        SELECT ?person ?personLabel ?image ?country ?gender ?deathDate
                        WHERE {
                            ?person wdt:P31 wd:Q5;
                                    wdt:P18 ?image;
                                    wdt:P27 ?country;
                                    wdt:P21 ?gender.
                            ${genderFilter}.
                            ${statusFilter}.
                            ?person rdfs:label ?personLabel.
                            FILTER (LANG(?personLabel) = "en").
                        }
                        ORDER BY RAND()
                        LIMIT 1
                    `;
                } else {
                    query = `
                        SELECT ?person ?personLabel ?image ?country ?gender ?deathDate
                        WHERE {
                            ?person wdt:P31 wd:Q5;
                                    wdt:P18 ?image;
                                    wdt:P27 ?country;
                                    wdt:P21 ?gender.
                            ${genderFilter}.
                            ${statusFilter}.
                            ?person rdfs:label ?personLabel.
                            FILTER (LANG(?personLabel) = "en").
                        }
                        OFFSET ${offset}
                        LIMIT ${settings.maxPeople}
                    `;
                }

                const endpoint = 'https://query.wikidata.org/sparql';
                const url = `${endpoint}?query=${encodeURIComponent(query)}&format=json&nocache=${Date.now()}`;

                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 15000);

                try {
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/sparql-results+json',
                            'User-Agent': 'SimplePhotoApp/1.0 (https://romanmod.github.io/personseei/; krv.mod@gmail.com)',
                        },
                        signal: controller.signal
                    });

                    clearTimeout(timeout);
                    const data = await response.json();
                    const list = data.results.bindings;

                    console.log(`Wikidata query time: ${(performance.now() - start).toFixed(0)}ms (${useRandom ? 'random' : 'fast'})`);

                    if (!list.length) {
                        console.warn(`No results for category ${category?.gender}/${category?.status}, attempt ${attempts + 1}`);
                        attempts++;
                        continue;
                    }

                    if (useRandom) {
                        return list[0];
                    } else {
                        const randomIndex = Math.floor(Math.random() * list.length);
                        return list[randomIndex];
                    }
                } catch (error) {
                    console.error(`Wikidata query failed: ${error.message}`);
                    attempts++;
                    if (attempts === maxAttempts) {
                        throw new Error('No person found after multiple attempts');
                    }
                }
            }
            throw new Error('No person found after maximum attempts');
        }

        function updateUI({ personLabel, gender, deathDate }) {
            const progress = document.getElementById('progress');
            const personName = document.getElementById('person-name');
            progress.textContent = '–§–æ—Ç–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ!';
            progress.classList.remove('loading', 'error');
            const genderText = gender?.value.split('/').pop() === 'Q6581097' ? '–ß–æ–ª–æ–≤—ñ–∫' : '–ñ—ñ–Ω–∫–∞';
            const statusText = deathDate ? '–ú–µ—Ä—Ü' : '–ñ–∏–≤–∏–π';
            personName.textContent = `${personLabel.value} (${genderText}, ${statusText})`;
        }

        function handleError(errorMessage) {
            const progress = document.getElementById('progress');
            const personImage = document.getElementById('person-image');
            const personName = document.getElementById('person-name');

            progress.textContent = errorMessage;
            progress.classList.add('error');
            progress.classList.remove('loading');
            personImage.src = 'https://via.placeholder.com/300';
            personName.textContent = '–¢–µ—Å—Ç–æ–≤–∏–π –ø–µ—Ä—Å–æ–Ω–∞–∂';
        }

        async function loadPerson(useRandom = true, category = null) {
            const startTime = performance.now();
            const mode = useRandom ? 'slow' : 'fast';
            const progress = document.getElementById('progress');
            const personImage = document.getElementById('person-image');
            const personName = document.getElementById('person-name');

            progress.textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö...';
            progress.classList.add('loading');
            progress.classList.remove('error');
            personImage.src = '';
            personName.textContent = '';
            personImage.classList.remove('loaded');

            let attempts = 0;
            const maxAttempts = 3;

            while (attempts < maxAttempts) {
                try {
                    const person = await fetchPersonData(useRandom, category);
                    if (!person) throw new Error('No person found');

                    progress.textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è...';
                    const fileName = decodeURIComponent(person.image.value.split('/').pop());
                    const imageUrl = await getCommonsImageUrl(fileName);
                    if (!imageUrl) throw new Error(`Invalid image: ${fileName}`);

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —á—ë—Ä–Ω–æ-–±–µ–ª–æ–µ —Ñ–æ—Ç–æ –¥–ª—è –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
                    if (settings.excludeBlackAndWhite) {
                        const isBW = await isBlackAndWhite(imageUrl);
                        if (isBW) {
                            console.warn(`Skipping black-and-white image for ${person.personLabel.value}`);
                            progress.textContent = '–ü—Ä–æ–ø—É—â–µ–Ω–æ —á—ë—Ä–Ω–æ-–±–µ–ª–æ–µ —Ñ–æ—Ç–æ, –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —ñ–Ω—à–æ–≥–æ...';
                            attempts++;
                            continue;
                        }
                    }

                    await loadImageWithFallback(imageUrl, personImage);
                    updateUI(person);
                    
                    const totalTime = performance.now() - startTime;
                    updateStats(mode, totalTime);
                    return;
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞:', error.message);
                    attempts++;
                    if (attempts === maxAttempts) {
                        let message = '–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è';
                        if (error.message.includes('Timeout')) {
                            message = '–¢–∞–π–º-–∞—É—Ç –∑–∞–ø–∏—Ç—É –¥–æ Wikidata';
                        } else if (error.message.includes('HTTP 400')) {
                            message = '–ù–µ–∫–æ—Ä–µ–∫—Ç–Ω–∏–π SPARQL-–∑–∞–ø–∏—Ç';
                        } else if (error.message.includes('No person found')) {
                            message = '–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –¥–∞–Ω–∏—Ö –ø—Ä–æ –ª—é–¥–∏–Ω—É';
                        } else if (error.message.includes('Invalid image')) {
                            message = `–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è: ${error.message}`;
                        }
                        handleError(message);
                        const totalTime = performance.now() - startTime;
                        document.getElementById(`time-${mode}`).textContent = 
                            `–ü–æ–º–∏–ª–∫–∞ –ø—ñ—Å–ª—è ${totalTime.toFixed(0)}–º—Å`;
                    }
                }
            }
        }

        async function loadPersonFromData(person, category = null) {
            const startTime = performance.now();
            const mode = 'fast';
            const progress = document.getElementById('progress');
            const personImage = document.getElementById('person-image');
            const personName = document.getElementById('person-name');

            progress.textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è...';
            progress.classList.add('loading');
            progress.classList.remove('error');
            personImage.src = '';
            personName.textContent = '';
            personImage.classList.remove('loaded');

            let attempts = 0;
            const maxAttempts = 3;

            while (attempts < maxAttempts) {
                try {
                    const fileName = decodeURIComponent(person.image.value.split('/').pop());
                    const imageUrl = await getCommonsImageUrl(fileName);
                    if (!imageUrl) throw new Error(`Invalid image: ${fileName}`);

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —á—ë—Ä–Ω–æ-–±–µ–ª–æ–µ —Ñ–æ—Ç–æ –¥–ª—è –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
                    if (settings.excludeBlackAndWhite) {
                        const isBW = await isBlackAndWhite(imageUrl);
                        if (isBW) {
                            console.warn(`Skipping black-and-white image for ${person.personLabel.value}`);
                            progress.textContent = '–ü—Ä–æ–ø—É—â–µ–Ω–æ —á—ë—Ä–Ω–æ-–±–µ–ª–æ–µ —Ñ–æ—Ç–æ, –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —ñ–Ω—à–æ–≥–æ...';
                            const newPerson = await fetchPersonData(false, category);
                            person = newPerson; // –û–±–Ω–æ–≤–ª—è–µ–º person –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–∏
                            attempts++;
                            continue;
                        }
                    }

                    await loadImageWithFallback(imageUrl, personImage);
                    updateUI(person);
                    
                    const totalTime = performance.now() - startTime;
                    updateStats(mode, totalTime);
                    return;
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞:', error.message);
                    attempts++;
                    if (attempts === maxAttempts) {
                        let message = error.message.includes('Invalid image') 
                            ? `–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è: ${error.message}`
                            : '–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è';
                        handleError(message);
                        const totalTime = performance.now() - startTime;
                        document.getElementById(`time-${mode}`).textContent = 
                            `–ü–æ–º–∏–ª–∫–∞ –ø—ñ—Å–ª—è ${totalTime.toFixed(0)}–º—Å`;
                    }
                }
            }
        }

        async function loadSession() {
            let sessionCount = 0;
            const categories = [
                { gender: 'male', status: 'alive' },
                { gender: 'male', status: 'deceased' },
                { gender: 'female', status: 'alive' },
                { gender: 'female', status: 'deceased' }
            ];
            const sessionList = [];

            // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
            document.getElementById('progress').textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –¥–ª—è —Å–µ—Å—ñ—ó...';
            try {
                const promises = categories.map(async (category, i) => {
                    const count = i % 2 === 0 ? 3 : 2; // 3, 2, 3, 2 –¥–ª—è 50/50
                    const results = [];
                    for (let j = 0; j < count; j++) {
                        try {
                            const person = await fetchPersonData(false, category);
                            results.push(person);
                        } catch (error) {
                            console.error(`Error in category ${category.gender}/${category.status}:`, error);
                            results.push(null);
                        }
                    }
                    return results;
                });
                const results = await Promise.all(promises);
                results.flat().forEach(person => sessionList.push(person));
            } catch (error) {
                console.error('Session data loading failed:', error);
                handleError('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –¥–∞–Ω—ñ –¥–ª—è —Å–µ—Å—ñ—ó');
                return;
            }

            // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–æ –æ—á–µ—Ä–µ–¥–∏
            for (let i = 0; i < sessionList.length; i++) {
                const person = sessionList[i];
                const category = categories[Math.floor((i % 10) / 2.5)];
                document.getElementById('progress').textContent = `–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ª—é–¥–∏–Ω–∏ ${sessionCount + 1} –∑ ${settings.sessionPeople}...`;
                if (person) {
                    await loadPersonFromData(person, category);
                } else {
                    handleError('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ª—é–¥–∏–Ω—É –¥–ª—è —Ü—ñ—î—ó –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó');
                }
                sessionCount++;
                if (sessionCount < settings.sessionPeople) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            document.getElementById('progress').textContent = `–°–µ—Å—ñ—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ (${settings.sessionPeople} –æ—Å—ñ–±)`;
        }

        window.onload = () => {
            loadSession();
        };
    </script>

</body>
</html>
