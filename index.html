<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>–ì—Ä–∞: –í–∏–ø–∞–¥–∫–æ–≤–∞ –ª—é–¥–∏–Ω–∞ –∑ Wikidata</title>
    <meta name="referrer" content="origin">
    <style>
        :root {
            --bg-color: #1C2526; /* Space Gray —Ç–µ–º–Ω—ã–π —Ñ–æ–Ω */
            --text-color: #E8ECEF;
            --button-bg: #2C3E50;
            --button-hover: #34495E;
            --button-text: #E8ECEF;
            --accent-color: #3498DB;
            --progress-color: #3498DB;
        }

        /* –°—Ç–∏–ª—å –¥–ª—è –¥–Ω–µ–≤–Ω–æ–π —Ç–µ–º—ã */
        body.day {
            --bg-color: #ECF0F1;
            --text-color: #2C3E50;
            --button-bg: #BDC3C7;
            --button-hover: #95A5A6;
            --button-text: #2C3E50;
            --accent-color: #2980B9;
            --progress-color: #2980B9;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
            padding: 40px;
            margin: 0;
            transition: all 0.3s ease;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 20px;
        }

        #person-image {
            display: block;
            max-width: 100%;
            max-height: 300px;
            width: auto;
            height: auto;
            border: 2px solid var(--button-bg);
            border-radius: 10px;
            margin: 0 auto;
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }

        #person-image.loaded {
            opacity: 1;
        }

        #person-name {
            margin-top: 15px;
            font-size: 1.5em;
            font-weight: bold;
        }

        #progress {
            margin-top: 20px;
            font-style: italic;
            color: var(--progress-color);
        }

        #progress.error {
            color: #E74C3C;
        }

        .btn-container {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        .btn-container button, select {
            padding: 10px 20px;
            font-size: 16px;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn-container button:hover, select:hover {
            background-color: var(--button-hover);
        }

        .time-info {
            margin-top: 5px;
            font-size: 0.9em;
            color: var(--text-color);
        }

        .stats {
            margin-top: 20px;
            padding: 10px;
            background-color: var(--button-bg);
            border-radius: 5px;
            display: inline-block;
        }

        .settings {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
    </style>
</head>
<body class="night">
    <div class="settings">
        <button id="theme-toggle">üåô –ù—ñ—á</button>
        <select id="language-select">
            <option value="uk" selected>–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</option>
            <option value="ru">–†—É—Å—Å–∫–∏–π</option>
            <option value="en">English</option>
            <option value="alien">üëΩ –Ü–Ω–æ–ø–ª–∞–Ω–µ—Ç–Ω–∞</option>
        </select>
        <select id="mode-select">
            <option value="open">–í—ñ–¥–∫—Ä–∏—Ç–∏–π</option>
            <option value="closed">–ó–∞–∫—Ä–∏—Ç–∏–π</option>
        </select>
    </div>

    <h1 id="title">–ì—Ä–∞: –í–∏–ø–∞–¥–∫–æ–≤–∞ –ª—é–¥–∏–Ω–∞ –∑ Wikidata</h1>
    <img id="person-image" src="" alt="–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ª—é–¥–∏–Ω–∏">
    <div id="person-name"></div>
    <div id="progress">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>

    <div class="btn-container">
        <button onclick="loadPerson(true)">üéØ –°—É–ø–µ—Ä –≤–∏–ø–∞–¥–∫–æ–≤–æ (–ø–æ–≤—ñ–ª—å–Ω–æ)</button>
        <div id="time-slow" class="time-info"></div>
        
        <button onclick="loadSession()">‚ö° –°–µ—Å—ñ—è (–∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∞ –≤–∏–ø–∞–¥–∫–æ–≤—ñ—Å—Ç—å)</button>
        <div id="time-fast" class="time-info"></div>
    </div>

    <div class="stats">
        <div>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:</div>
        <div id="stats-slow">–ü–æ–≤—ñ–ª—å–Ω–∏–π —Ä–µ–∂–∏–º: -</div>
        <div id="stats-fast">–®–≤–∏–¥–∫–∏–π —Ä–µ–∂–∏–º: -</div>
    </div>

    <script>
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        const settings = {
            superRandomPeople: true,
            dynamicOffset: true,
            maxOffset: 2000,
            maxPeople: 300,
            sessionPeople: 10,
            genderRatio: { male: 50, female: 50 },
            statusRatio: { alive: 50, deceased: 50 },
            birthYearFilter: 1950,
            excludeBlackAndWhite: false,
            selectedCountries: ['ua', 'us'],
            countryMap: {
                'ua': 'Q212',
                'us': 'Q30',
                'ru': 'Q159',
                'de': 'Q183',
                'gb': 'Q145'
            },
            strictCountryFilter: false
        };

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        const stats = {
            slow: { count: 0, totalTime: 0, lastTime: 0 },
            fast: { count: 0, totalTime: 0, lastTime: 0 }
        };

        // –ö—ç—à
        const rgbHslCache = JSON.parse(localStorage.getItem('rgbHslCache')) || {};
        const wikidataCache = JSON.parse(localStorage.getItem('wikidataCache')) || {};

        // –ü–µ—Ä–µ–≤–æ–¥—ã
        const translations = {
            uk: {
                title: '–ì—Ä–∞: –í–∏–ø–∞–¥–∫–æ–≤–∞ –ª—é–¥–∏–Ω–∞ –∑ Wikidata',
                loading: '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...',
                slowButton: 'üéØ –°—É–ø–µ—Ä –≤–∏–ø–∞–¥–∫–æ–≤–æ (–ø–æ–≤—ñ–ª—å–Ω–æ)',
                fastButton: '‚ö° –°–µ—Å—ñ—è (–∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∞ –≤–∏–ø–∞–¥–∫–æ–≤—ñ—Å—Ç—å)',
                stats: '–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:',
                slowStats: '–ü–æ–≤—ñ–ª—å–Ω–∏–π —Ä–µ–∂–∏–º: -',
                fastStats: '–®–≤–∏–¥–∫–∏–π —Ä–µ–∂–∏–º: -',
                themeNight: 'üåô –ù—ñ—á',
                themeDay: '‚òÄ –î–µ–Ω—å'
            },
            ru: {
                title: '–ò–≥—Ä–∞: –°–ª—É—á–∞–π–Ω—ã–π —á–µ–ª–æ–≤–µ–∫ –∏–∑ Wikidata',
                loading: '–ó–∞–≥—Ä—É–∑–∫–∞...',
                slowButton: 'üéØ –°—É–ø–µ—Ä —Å–ª—É—á–∞–π–Ω–æ (–º–µ–¥–ª–µ–Ω–Ω–æ)',
                fastButton: '‚ö° –°–µ—Å—Å–∏—è (—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å)',
                stats: '–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:',
                slowStats: '–ú–µ–¥–ª–µ–Ω–Ω—ã–π —Ä–µ–∂–∏–º: -',
                fastStats: '–ë—ã—Å—Ç—Ä—ã–π —Ä–µ–∂–∏–º: -',
                themeNight: 'üåô –ù–æ—á—å',
                themeDay: '‚òÄ –î–µ–Ω—å'
            },
            en: {
                title: 'Game: Random Person from Wikidata',
                loading: 'Loading...',
                slowButton: 'üéØ Super Random (slow)',
                fastButton: '‚ö° Session (balanced randomness)',
                stats: 'Loading Statistics:',
                slowStats: 'Slow Mode: -',
                fastStats: 'Fast Mode: -',
                themeNight: 'üåô Night',
                themeDay: '‚òÄ Day'
            },
            alien: {
                title: 'üëæ ‚ä∏‚çü‚ä∏: ‚ä∏‚çü‚ä∏ ‚ä∏‚çü‚ä∏‚ä∏ ‚ä∏‚çü Wikidata',
                loading: '‚ä∏‚çü‚ä∏...',
                slowButton: 'üéØ ‚ä∏‚çü‚ä∏ ‚ä∏‚çü‚ä∏ (‚ä∏‚çü‚ä∏)',
                fastButton: '‚ö° ‚ä∏‚çü‚ä∏ (‚ä∏‚çü‚ä∏ ‚ä∏‚çü‚ä∏)',
                stats: '‚ä∏‚çü‚ä∏ ‚ä∏‚çü‚ä∏:',
                slowStats: '‚ä∏‚çü‚ä∏ ‚ä∏‚çü‚ä∏: -',
                fastStats: '‚ä∏‚çü‚ä∏ ‚ä∏‚çü‚ä∏: -',
                themeNight: 'üåô ‚ä∏‚çü‚ä∏',
                themeDay: '‚òÄ ‚ä∏‚çü‚ä∏'
            }
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
        let isNight = localStorage.getItem('theme') !== 'day';
        let selectedLanguage = localStorage.getItem('language') || 'uk';
        let gameMode = localStorage.getItem('mode') || 'open';

        document.body.classList.toggle('day', !isNight);
        document.getElementById('language-select').value = selectedLanguage;
        document.getElementById('mode-select').value = gameMode;

        // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        console.log('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–∏–ª—è Space Gray');
        console.log('–¢–µ–º–∞: ' + (isNight ? '–Ω–æ—á—å' : '–¥–µ–Ω—å'));
        console.log('–í—ã–±—Ä–∞–Ω —è–∑—ã–∫: ' + selectedLanguage);
        console.log('–í—ã–±—Ä–∞–Ω —Ä–µ–∂–∏–º: ' + gameMode);

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –ø–æ —è–∑—ã–∫—É
        function updateLanguage() {
            const texts = translations[selectedLanguage];
            document.getElementById('title').textContent = texts.title;
            document.getElementById('progress').textContent = texts.loading;
            document.querySelector('button[onclick="loadPerson(true)"]').textContent = texts.slowButton;
            document.querySelector('button[onclick="loadSession()"]').textContent = texts.fastButton;
            document.querySelector('.stats div:first-child').textContent = texts.stats;
            document.getElementById('stats-slow').textContent = texts.slowStats;
            document.getElementById('stats-fast').textContent = texts.fastStats;
            document.getElementById('theme-toggle').textContent = isNight ? texts.themeNight : texts.themeDay;
        }

        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ç–µ–º—ã
        document.getElementById('theme-toggle').addEventListener('click', () => {
            isNight = !isNight;
            document.body.classList.toggle('day', !isNight);
            localStorage.setItem('theme', isNight ? 'night' : 'day');
            updateLanguage();
            console.log('–¢–µ–º–∞ –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞: ' + (isNight ? '–Ω–æ—á—å' : '–¥–µ–Ω—å'));
        });

        // –°–º–µ–Ω–∞ —è–∑—ã–∫–∞
        document.getElementById('language-select').addEventListener('change', (e) => {
            selectedLanguage = e.target.value;
            localStorage.setItem('language', selectedLanguage);
            updateLanguage();
            console.log('–í—ã–±—Ä–∞–Ω —è–∑—ã–∫: ' + selectedLanguage);
        });

        // –°–º–µ–Ω–∞ —Ä–µ–∂–∏–º–∞
        document.getElementById('mode-select').addEventListener('change', (e) => {
            gameMode = e.target.value;
            localStorage.setItem('mode', gameMode);
            console.log('–í—ã–±—Ä–∞–Ω —Ä–µ–∂–∏–º: ' + gameMode);
        });

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        function updateStats(mode, time) {
            stats[mode].count++;
            stats[mode].totalTime += time;
            stats[mode].lastTime = time;
            const avgTime = stats[mode].totalTime / stats[mode].count;
            document.getElementById(`stats-${mode}`).textContent = 
                `${mode === 'slow' ? translations[selectedLanguage].slowStats.split(':')[0] : translations[selectedLanguage].fastStats.split(':')[0]}: ` +
                `–û—Å—Ç–∞–Ω–Ω—î: ${time.toFixed(0)}–º—Å, ` +
                `–°–µ—Ä–µ–¥–Ω—î: ${avgTime.toFixed(0)}–º—Å, ` +
                `–ó–∞–ø–∏—Ç—ñ–≤: ${stats[mode].count}`;
            document.getElementById(`time-${mode}`).textContent = 
                `–ß–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è: ${time.toFixed(0)}–º—Å`;
        }

        // –§—É–Ω–∫—Ü–∏–∏ –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h, s, l];
        }

        async function isBlackAndWhite(imageUrl) {
            if (!settings.excludeBlackAndWhite) return false;

            if (rgbHslCache[imageUrl] !== undefined) {
                console.log(`Using cached RGB+HSL result for ${imageUrl}: ${rgbHslCache[imageUrl] ? 'black-and-white' : 'color'}`);
                return rgbHslCache[imageUrl];
            }

            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 100;
                    canvas.height = 100;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, 100, 100);

                    const imageData = ctx.getImageData(0, 0, 100, 100).data;
                    let rSum = 0, gSum = 0, bSum = 0;
                    let rSquareSum = 0, gSquareSum = 0, bSquareSum = 0;
                    let saturationSum = 0;
                    let count = 0;

                    for (let i = 0; i < imageData.length; i += 4) {
                        const r = imageData[i];
                        const g = imageData[i + 1];
                        const b = imageData[i + 2];
                        rSum += r;
                        gSum += g;
                        bSum += b;
                        rSquareSum += r * r;
                        gSquareSum += g * g;
                        bSquareSum += b * b;

                        const [, s] = rgbToHsl(r, g, b);
                        saturationSum += s;
                        count++;
                    }

                    const rMean = rSum / count;
                    const gMean = gSum / count;
                    const bMean = bSum / count;
                    const rStdDev = Math.sqrt((rSquareSum / count) - (rMean * rMean));
                    const gStdDev = Math.sqrt((gSquareSum / count) - (gMean * gMean));
                    const bStdDev = Math.sqrt((bSquareSum / count) - (bMean * bMean));
                    const meanSaturation = saturationSum / count;

                    const isBW = rStdDev < 20 && gStdDev < 20 && bStdDev < 20 && meanSaturation < 0.2;
                    console.log(`Image ${imageUrl} is ${isBW ? 'black-and-white' : 'color'} ` +
                                `(R:${rStdDev.toFixed(2)}, G:${gStdDev.toFixed(2)}, B:${bStdDev.toFixed(2)}, Saturation:${(meanSaturation * 100).toFixed(2)}%)`);
                    
                    rgbHslCache[imageUrl] = isBW;
                    localStorage.setItem('rgbHslCache', JSON.stringify(rgbHslCache));
                    
                    resolve(isBW);
                };
                img.onerror = () => {
                    console.error(`Failed to load image for RGB+HSL analysis: ${imageUrl}`);
                    resolve(false);
                };
                img.src = imageUrl;
            });
        }

        async function getCommonsImageUrl(fileName) {
            const start = performance.now();
            try {
                const response = await fetch(`https://commons.wikimedia.org/w/api.php?action=query&titles=File:${encodeURIComponent(fileName)}&prop=imageinfo&iiprop=url&format=json&origin=*`);
                if (!response.ok) throw new Error(`Commons API error: ${response.status}`);
                const data = await response.json();
                const pages = data.query.pages;
                const page = pages[Object.keys(pages)[0]];
                console.log(`Commons API time: ${(performance.now() - start).toFixed(0)}ms`);
                if (!page.imageinfo) {
                    console.error(`No imageinfo for file: ${fileName}`);
                    return null;
                }
                return page.imageinfo[0].url;
            } catch (error) {
                console.error(`Failed to fetch Commons image for ${fileName}:`, error.message);
                return null;
            }
        }

        async function loadImageWithFallback(url, element) {
            return new Promise((resolve, reject) => {
                element.classList.remove('loaded');
                const proxyUrl = `https://images.weserv.nl/?url=${encodeURIComponent(url)}`;
                console.log(`Attempting to load image via proxy: ${proxyUrl}`);
                
                const cleanup = () => {
                    element.onload = null;
                    element.onerror = null;
                };

                element.onload = () => {
                    console.log(`Image loaded successfully via proxy: ${proxyUrl}`);
                    element.classList.add('loaded');
                    cleanup();
                    resolve();
                };
                element.onerror = () => {
                    console.error(`Proxy image load failed: ${proxyUrl}`);
                    element.src = 'https://via.placeholder.com/300';
                    element.classList.add('loaded');
                    cleanup();
                    reject(new Error(`Proxy image load failed: ${proxyUrl}`));
                };
                
                element.src = proxyUrl;
            });
        }

        async function fetchPersonData(useRandom = true, category = null) {
            const start = performance.now();
            let query;
            let attempts = 0;
            const maxAttempts = 5;

            const cacheKey = `${useRandom}-${category?.gender || 'any'}-${category?.status || 'any'}`;
            if (wikidataCache[cacheKey] && wikidataCache[cacheKey].length > 0) {
                console.log(`Using cached data for ${cacheKey}`);
                return wikidataCache[cacheKey][Math.floor(Math.random() * wikidataCache[cacheKey].length)];
            }

            const genderFilter = category?.gender === 'male' ? 'FILTER(?gender = wd:Q6581097)' :
                                category?.gender === 'female' ? 'FILTER(?gender = wd:Q6581072)' :
                                'FILTER(?gender IN (wd:Q6581097, wd:Q6581072))';
            const statusFilter = category?.status === 'alive' ? 'FILTER NOT EXISTS { ?person wdt:P570 ?deathDate }' :
                                category?.status === 'deceased' ? '?person wdt:P570 ?deathDate' :
                                'OPTIONAL { ?person wdt:P570 ?deathDate }';
            const birthDateFilter = `FILTER(?birthDate >= "${settings.birthYearFilter}-01-01"^^xsd:dateTime).`;
            const countryFilter = settings.selectedCountries === 'all' ? '' :
                                 `FILTER(?country IN (${settings.selectedCountries
                                     .map(code => `wd:${settings.countryMap[code]}`)
                                     .filter(id => id)
                                     .join(', ')})).`;

            while (attempts < maxAttempts) {
                const offset = settings.dynamicOffset ? Math.floor(Math.random() * settings.maxOffset) : 0;
                if (useRandom && settings.superRandomPeople) {
                    query = `
                        SELECT ?person ?personLabel ?image ?country ?gender ?deathDate ?birthDate
                        WHERE {
                            ?person wdt:P31 wd:Q5;
                                    wdt:P18 ?image;
                                    wdt:P21 ?gender;
                                    wdt:P569 ?birthDate.
                            ${settings.strictCountryFilter ? '' : 'OPTIONAL'} { ?person wdt:P27 ?country }.
                            ${genderFilter}.
                            ${statusFilter}.
                            ${birthDateFilter}
                            ${settings.selectedCountries !== 'all' && settings.strictCountryFilter ? countryFilter : ''}
                            ?person rdfs:label ?personLabel.
                            FILTER (LANG(?personLabel) = "en").
                        }
                        ORDER BY RAND()
                        LIMIT 10
                    `;
                } else {
                    query = `
                        SELECT ?person ?personLabel ?image ?country ?gender ?deathDate ?birthDate
                        WHERE {
                            ?person wdt:P31 wd:Q5;
                                    wdt:P18 ?image;
                                    wdt:P21 ?gender;
                                    wdt:P569 ?birthDate.
                            ${settings.strictCountryFilter ? '' : 'OPTIONAL'} { ?person wdt:P27 ?country }.
                            ${genderFilter}.
                            ${statusFilter}.
                            ${birthDateFilter}
                            ${settings.selectedCountries !== 'all' && settings.strictCountryFilter ? countryFilter : ''}
                            ?person rdfs:label ?personLabel.
                            FILTER (LANG(?personLabel) = "en").
                        }
                        OFFSET ${offset}
                        LIMIT ${settings.maxPeople}
                    `;
                }

                const endpoint = 'https://query.wikidata.org/sparql';
                const url = `${endpoint}?query=${encodeURIComponent(query)}&format=json&nocache=${Date.now()}`;

                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 45000);

                try {
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/sparql-results+json',
                            'User-Agent': 'SimplePhotoApp/1.0 (https://romanmod.github.io/personseei/; krv.mod@gmail.com)',
                        },
                        signal: controller.signal
                    });

                    clearTimeout(timeout);
                    const data = await response.json();
                    const list = data.results.bindings;

                    console.log(`Wikidata query time: ${(performance.now() - start).toFixed(0)}ms (${useRandom ? 'random' : 'fast'})`);

                    if (!list.length) {
                        console.warn(`No results for category ${category?.gender || 'any'}/${category?.status || 'any'}, attempt ${attempts + 1}`);
                        attempts++;
                        continue;
                    }

                    wikidataCache[cacheKey] = (wikidataCache[cacheKey] || []).concat(list).slice(-100);
                    localStorage.setItem('wikidataCache', JSON.stringify(wikidataCache));

                    return list[Math.floor(Math.random() * list.length)];
                } catch (error) {
                    console.error(`Wikidata query failed: ${error.message}`);
                    attempts++;
                    if (attempts === maxAttempts) {
                        throw new Error(`No person found after ${maxAttempts} attempts`);
                    }
                }
            }
            throw new Error(`No person found after ${maxAttempts} attempts`);
        }

        function updateUI({ personLabel, gender, deathDate, birthDate }) {
            const progress = document.getElementById('progress');
            const personName = document.getElementById('person-name');
            const genderText = gender?.value.split('/').pop() === 'Q6581097' ? translations[selectedLanguage].male || '–ß–æ–ª–æ–≤—ñ–∫' : translations[selectedLanguage].female || '–ñ—ñ–Ω–∫–∞';
            const statusText = deathDate ? translations[selectedLanguage].deceased || '–ú–µ—Ä—Ü' : translations[selectedLanguage].alive || '–ñ–∏–≤–∏–π';
            const birthDateText = birthDate ? new Date(birthDate.value).toLocaleDateString('uk-UA') : translations[selectedLanguage].unknown || '–ù–µ–≤—ñ–¥–æ–º–æ';
            const nameText = `${personLabel.value} (${genderText}, ${statusText}, –ù–∞—Ä–æ–¥–∂–µ–Ω–Ω—è: ${birthDateText})`;
            
            requestAnimationFrame(() => {
                progress.textContent = translations[selectedLanguage].loaded || '–§–æ—Ç–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ!';
                progress.classList.remove('loading', 'error');
                personName.textContent = nameText;
            });
        }

        function handleError(errorMessage) {
            const progress = document.getElementById('progress');
            const personImage = document.getElementById('person-image');
            const personName = document.getElementById('person-name');

            requestAnimationFrame(() => {
                progress.textContent = translations[selectedLanguage].error || errorMessage;
                progress.classList.add('error');
                progress.classList.remove('loading');
                personImage.src = 'https://via.placeholder.com/300';
                personName.textContent = translations[selectedLanguage].testPerson || '–¢–µ—Å—Ç–æ–≤–∏–π –ø–µ—Ä—Å–æ–Ω–∞–∂';
            });
        }

        async function loadPerson(useRandom = true, category = null) {
            const startTime = performance.now();
            const mode = useRandom ? 'slow' : 'fast';
            console.time(`loadPerson-${mode}`);

            const progress = document.getElementById('progress');
            const personImage = document.getElementById('person-image');
            const personName = document.getElementById('person-name');

            requestAnimationFrame(() => {
                progress.textContent = translations[selectedLanguage].loadingData || '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö...';
                progress.classList.add('loading');
                progress.classList.remove('error');
                personImage.src = '';
                personName.textContent = '';
                personImage.classList.remove('loaded');
            });

            let attempts = 0;
            const maxAttempts = 5;

            while (attempts < maxAttempts) {
                try {
                    const person = await fetchPersonData(useRandom, category);
                    if (!person) throw new Error('No person found');

                    progress.textContent = translations[selectedLanguage].loadingImage || '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è...';
                    const fileName = decodeURIComponent(person.image.value.split('/').pop());
                    console.log(`Fetching image for file: ${fileName}`);
                    const imageUrl = await getCommonsImageUrl(fileName);
                    if (!imageUrl) throw new Error(`Invalid image: ${fileName}`);

                    if (settings.excludeBlackAndWhite) {
                        const isBW = await isBlackAndWhite(imageUrl);
                        if (isBW) {
                            console.warn(`Skipping black-and-white image for ${person.personLabel.value}`);
                            progress.textContent = translations[selectedLanguage].skipBW || '–ü—Ä–æ–ø—É—â–µ–Ω–æ —á—ë—Ä–Ω–æ-–±–µ–ª–æ–µ —Ñ–æ—Ç–æ, –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —ñ–Ω—à–æ–≥–æ...';
                            attempts++;
                            continue;
                        }
                    }

                    try {
                        await loadImageWithFallback(imageUrl, personImage);
                        updateUI(person);
                        
                        const totalTime = performance.now() - startTime;
                        updateStats(mode, totalTime);
                        console.timeEnd(`loadPerson-${mode}`);
                        return;
                    } catch (imageError) {
                        console.error(`Image load error: ${imageError.message}`);
                        progress.textContent = translations[selectedLanguage].imageError || '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è, –ø—Ä–æ–±—É—î–º–æ —ñ–Ω—à–æ–≥–æ...';
                        attempts++;
                        continue;
                    }
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞:', error.message);
                    attempts++;
                    if (attempts === maxAttempts) {
                        let message = translations[selectedLanguage].error || '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏';
                        if (error.message.includes('Timeout')) {
                            message = translations[selectedLanguage].timeout || '–¢–∞–π–º-–∞—É—Ç –∑–∞–ø—Ä–æ—Å–∞ –∫ Wikidata';
                        } else if (error.message.includes('HTTP 400')) {
                            message = translations[selectedLanguage].badRequest || '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π SPARQL-–∑–∞–ø—Ä–æ—Å';
                        } else if (error.message.includes('No person found')) {
                            message = translations[selectedLanguage].noPerson || '–ù–µ –Ω–∞–π–¥–µ–Ω–æ –¥–∞–Ω–Ω—ã—Ö –æ —á–µ–ª–æ–≤–µ–∫–µ';
                        } else if (error.message.includes('Invalid image')) {
                            message = translations[selectedLanguage].invalidImage || `–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${error.message}`;
                        }
                        handleError(message);
                        const totalTime = performance.now() - startTime;
                        document.getElementById(`time-${mode}`).textContent = 
                            translations[selectedLanguage].errorTime || `–û—à–∏–±–∫–∞ –ø–æ—Å–ª–µ ${totalTime.toFixed(0)}–º—Å`;
                        console.timeEnd(`loadPerson-${mode}`);
                    }
                }
            }
        }

        async function loadPersonFromData(person, category = null) {
            const startTime = performance.now();
            const mode = 'fast';
            console.time(`loadPersonFromData-${mode}`);

            const progress = document.getElementById('progress');
            const personImage = document.getElementById('person-image');
            const personName = document.getElementById('person-name');

            requestAnimationFrame(() => {
                progress.textContent = translations[selectedLanguage].loadingImage || '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è...';
                progress.classList.add('loading');
                progress.classList.remove('error');
                personImage.src = '';
                personName.textContent = '';
                personImage.classList.remove('loaded');
            });

            let attempts = 0;
            const maxAttempts = 5;

            while (attempts < maxAttempts) {
                try {
                    const fileName = decodeURIComponent(person.image.value.split('/').pop());
                    console.log(`Fetching image for file: ${fileName}`);
                    const imageUrl = await getCommonsImageUrl(fileName);
                    if (!imageUrl) throw new Error(`Invalid image: ${fileName}`);

                    if (settings.excludeBlackAndWhite) {
                        const isBW = await isBlackAndWhite(imageUrl);
                        if (isBW) {
                            console.warn(`Skipping black-and-white image for ${person.personLabel.value}`);
                            progress.textContent = translations[selectedLanguage].skipBW || '–ü—Ä–æ–ø—É—â–µ–Ω–æ —á—ë—Ä–Ω–æ-–±–µ–ª–æ–µ —Ñ–æ—Ç–æ, –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —ñ–Ω—à–æ–≥–æ...';
                            const newPerson = await fetchPersonData(false, category);
                            person = newPerson;
                            attempts++;
                            continue;
                        }
                    }

                    try {
                        await loadImageWithFallback(imageUrl, personImage);
                        updateUI(person);
                        
                        const totalTime = performance.now() - startTime;
                        updateStats(mode, totalTime);
                        console.timeEnd(`loadPersonFromData-${mode}`);
                        return;
                    } catch (imageError) {
                        console.error(`Image load error: ${imageError.message}`);
                        progress.textContent = translations[selectedLanguage].imageError || '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è, –ø—Ä–æ–±—É—î–º–æ —ñ–Ω—à–æ–≥–æ...';
                        attempts++;
                        const newPerson = await fetchPersonData(false, category);
                        person = newPerson;
                        continue;
                    }
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞:', error.message);
                    attempts++;
                    if (attempts === maxAttempts) {
                        let message = error.message.includes('Invalid image') 
                            ? translations[selectedLanguage].invalidImage || `–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${error.message}`
                            : translations[selectedLanguage].error || '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏';
                        handleError(message);
                        const totalTime = performance.now() - startTime;
                        document.getElementById(`time-${mode}`).textContent = 
                            translations[selectedLanguage].errorTime || `–û—à–∏–±–∫–∞ –ø–æ—Å–ª–µ ${totalTime.toFixed(0)}–º—Å`;
                        console.timeEnd(`loadPersonFromData-${mode}`);
                    }
                }
            }
        }

        async function loadSession() {
            const startTime = performance.now();
            console.time('loadSession');
            let sessionCount = 0;
            const categories = [
                { gender: 'male', status: 'alive' },
                { gender: 'male', status: 'deceased' },
                { gender: 'female', status: 'alive' },
                { gender: 'female', status: 'deceased' }
            ];
            const sessionList = [];

            document.getElementById('progress').textContent = translations[selectedLanguage].loadingSession || '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –¥–ª—è —Å–µ—Å—ñ—ó...';
            try {
                const promises = categories.map(async (category, i) => {
                    const count = i % 2 === 0 ? 3 : 2;
                    const results = [];
                    for (let j = 0; j < count; j++) {
                        try {
                            const person = await fetchPersonData(false, category);
                            results.push(person);
                        } catch (error) {
                            console.error(`Error in category ${category.gender}/${category.status}:`, error);
                            results.push(null);
                        }
                    }
                    return results;
                });
                const results = await Promise.all(promises);
                results.flat().forEach(person => sessionList.push(person));
            } catch (error) {
                console.error('Session data loading failed:', error);
                handleError(translations[selectedLanguage].sessionError || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–µ—Å—Å–∏–∏');
                console.timeEnd('loadSession');
                return;
            }

            for (let i = 0; i < sessionList.length; i++) {
                const person = sessionList[i];
                const category = categories[Math.floor((i % 10) / 2.5)];
                document.getElementById('progress').textContent = translations[selectedLanguage].loadingPerson?.replace('{n}', sessionCount + 1).replace('{total}', settings.sessionPeople) || `–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ª—é–¥–∏–Ω–∏ ${sessionCount + 1} –∑ ${settings.sessionPeople}...`;
                if (person) {
                    await loadPersonFromData(person, category);
                } else {
                    handleError(translations[selectedLanguage].personError || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —á–µ–ª–æ–≤–µ–∫–∞ –¥–ª—è —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏');
                }
                sessionCount++;
                if (sessionCount < settings.sessionPeople) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            document.getElementById('progress').textContent = translations[selectedLanguage].sessionComplete?.replace('{total}', settings.sessionPeople) || `–°–µ—Å—ñ—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ (${settings.sessionPeople} –æ—Å—ñ–±)`;
            console.timeEnd('loadSession');
            console.log(`Total session time: ${(performance.now() - startTime).toFixed(0)}ms`);
        }

        window.onload = () => {
            updateLanguage();
            loadSession();
        };
    </script>
</body>
</html>
